# 시간 복잡도와 공간 복잡도 (Big O 표기법)

알고리즘의 성능을 분석할 때, **"얼마나 빠른가?"(시간 복잡도)**와 **"얼마나 많은 메모리를 사용하는가?"(공간 복잡도)**는 가장 중요한 척도입니다. **복잡도(Complexity)**는 입력 데이터의 크기(`n`)가 증가할 때, 알고리즘의 실행 시간이나 메모리 사용량이 얼마나 증가하는지를 나타냅니다.

---

### 1. 시간 복잡도 (Time Complexity)

- **정의:** 입력 데이터의 크기 `n`에 대해 알고리즘이 실행되는 데 걸리는 시간을 나타냅니다. 실제 실행 시간(초)이 아닌, **연산의 수행 횟수**를 기준으로 측정합니다.
- **목표:** 데이터가 많아져도 실행 시간이 과도하게 길어지지 않는, 즉 시간 복잡도가 낮은 '효율적인' 알고리즘을 설계하는 것이 목표입니다.

### 2. 공간 복잡도 (Space Complexity)

- **정의:** 입력 데이터의 크기 `n`에 대해 알고리즘이 실행되는 동안 사용하는 메모리 공간의 양을 나타냅니다.
- **고려사항:** 변수, 자료구조, 재귀 호출 스택 등 알고리즘 실행에 필요한 모든 메모리를 포함합니다.
- **최근 경향:** 하드웨어의 발전으로 메모리 공간이 풍부해지면서, 시간 복잡도에 비해 중요도가 다소 낮아지긴 했지만, 대용량 데이터를 다루거나 임베디드 시스템과 같이 메모리가 제한적인 환경에서는 여전히 매우 중요합니다.

---

### 3. 빅오(Big O) 표기법

빅오 표기법은 알고리즘의 복잡도를 나타내는 가장 일반적인 방법입니다. 이는 입력 데이터의 크기 `n`이 무한대로 커질 때, 함수의 증가율을 지배하는 **최고차항**만을 고려하여 복잡도의 **상한선(Upper Bound)**을 나타냅니다.

- **핵심:** "입력 크기 `n`이 매우 커질 때, 이 알고리즘의 성능은 최악의 경우(Worst-case) `O(f(n))`보다는 나빠지지 않는다"를 의미합니다.
- **특징:**
  - 최고차항만 남깁니다. (예: `O(3n² + 2n + 1)` -> `O(n²)`)
  - 계수(상수)는 무시합니다. (예: `O(3n²)` -> `O(n²)`)

#### 주요 빅오 복잡도 (빠른 순 -> 느린 순)

- **`O(1)` - 상수 시간 (Constant Time):**
  - 입력 데이터의 크기에 상관없이 실행 시간이 일정합니다.
  - 예: 배열의 특정 인덱스에 접근하기, 해시 테이블의 삽입/삭제.

- **`O(log n)` - 로그 시간 (Logarithmic Time):**
  - 실행 시간이 입력 데이터 크기의 로그에 비례합니다. 데이터가 두 배로 늘어나도, 실행 시간은 한 단계만 늘어나는 매우 효율적인 알고리즘입니다.
  - 예: 이진 탐색(Binary Search).

- **`O(n)` - 선형 시간 (Linear Time):**
  - 실행 시간이 입력 데이터 크기에 정비례합니다.
  - 예: 배열의 모든 요소를 한 번씩 순회하기 (`for` 루프).

- **`O(n log n)` - 로그 선형 시간 (Log-linear Time):**
  - `O(n)`과 `O(log n)`이 결합된 형태로, 효율적인 정렬 알고리즘에서 많이 나타납니다.
  - 예: 병합 정렬(Merge Sort), 퀵 정렬(Quick Sort)의 평균 경우.

- **`O(n²)` - 이차 시간 (Quadratic Time):**
  - 실행 시간이 입력 데이터 크기의 제곱에 비례합니다.
  - 예: 이중 `for` 루프를 사용하여 배열의 모든 요소 쌍을 비교하기. (버블 정렬, 삽입 정렬)

- **`O(2ⁿ)` - 지수 시간 (Exponential Time):**
  - 실행 시간이 입력 데이터 크기에 대해 기하급수적으로 증가합니다. `n`이 조금만 커져도 매우 느려져 사실상 사용하기 어려운 알고리즘입니다.
  - 예: 피보나치 수열의 단순 재귀적 계산.

알고리즘의 복잡도를 이해하고 분석하는 능력은 효율적인 소프트웨어를 개발하고, 대용량 데이터를 처리하는 머신러닝 모델을 설계하는 데 필수적인 역량입니다.
