# 기본 자료구조: 배열, 연결 리스트, 스택, 큐

**자료구조(Data Structure)**는 여러 데이터들을 특정 방식에 따라 효율적으로 저장하고 관리하기 위한 구조입니다. 어떤 자료구조를 선택하느냐에 따라 프로그램의 성능이 크게 달라질 수 있습니다. 여기서는 가장 기본적이면서도 중요한 네 가지 자료구조를 알아봅니다.

---

### 1. 배열 (Array)

- **정의:** 같은 타입의 데이터 여러 개를 **연속된 메모리 공간**에 저장하는 가장 기본적인 자료구조입니다.
- **특징:**
  - 각 데이터는 **인덱스(index)**를 가지며, 이 인덱스를 통해 해당 데이터에 직접 접근할 수 있습니다.
  - 인덱스를 통한 접근 속도가 매우 빠릅니다 (`O(1)`).
  - 크기가 고정되어 있어, 처음에 정해진 크기를 변경하기 어렵습니다. (파이썬의 `list`는 동적 배열로, 내부적으로 크기 조절을 자동으로 해주어 이 단점을 보완합니다.)
  - 중간에 데이터를 삽입하거나 삭제하는 경우, 그 뒤의 모든 요소들을 이동시켜야 하므로 비효율적입니다 (`O(n)`).

- **주요 연산:**
  - `Access`: `arr[i]` - `O(1)`
  - `Search`: `O(n)` (특정 값을 찾기 위해 순차적으로 탐색)
  - `Insert/Delete`: `O(n)`

---

### 2. 연결 리스트 (Linked List)

- **정의:** 여러 개의 **노드(Node)**가 순차적으로 연결된 형태의 자료구조입니다. 각 노드는 데이터와 다음 노드를 가리키는 포인터(pointer)로 구성됩니다.
- **특징:**
  - 데이터가 메모리 상에 흩어져 있어도 괜찮습니다 (비연속적).
  - 데이터의 삽입과 삭제가 매우 빠릅니다. 해당 노드의 포인터만 변경하면 되기 때문입니다 (`O(1)`).
  - 특정 위치의 데이터에 접근하려면 처음부터 순서대로 찾아가야 하므로, 탐색 속도가 느립니다 (`O(n)`).
  - 포인터를 저장하기 위한 추가적인 메모리 공간이 필요합니다.

- **주요 연산:**
  - `Access`: `O(n)`
  - `Search`: `O(n)`
  - `Insert/Delete`: `O(1)` (단, 삽입/삭제할 위치를 이미 알고 있을 경우)

---

### 3. 스택 (Stack)

- **정의:** 데이터가 한쪽 끝에서만 추가되고 삭제되는 **LIFO(Last-In, First-Out)**, 즉 '후입선출' 방식의 자료구조입니다. 마치 쌓여있는 접시 더미에서 맨 위의 접시를 꺼내고 쌓는 것과 같습니다.
- **주요 연산:**
  - **`Push`:** 스택의 맨 위에 데이터를 추가합니다.
  - **`Pop`:** 스택의 맨 위에서 데이터를 제거하고 반환합니다.
- **사용 예시:**
  - 웹 브라우저의 '뒤로 가기' 기능
  - 함수 호출 스택 (재귀 함수 등)
  - 괄호 검사

```python
stack = []
stack.append(1) # Push 1
stack.append(2) # Push 2
stack.append(3) # Push 3

print(stack) # [1, 2, 3]

item = stack.pop() # Pop
print(item) # 3
print(stack) # [1, 2]
```

---

### 4. 큐 (Queue)

- **정의:** 데이터가 한쪽 끝(rear)에서 추가되고, 다른 쪽 끝(front)에서 삭제되는 **FIFO(First-In, First-Out)**, 즉 '선입선출' 방식의 자료구조입니다. 은행 창구나 놀이공원에서 줄을 서는 것과 같습니다.
- **주요 연산:**
  - **`Enqueue`:** 큐의 뒤(rear)에 데이터를 추가합니다.
  - **`Dequeue`:** 큐의 앞(front)에서 데이터를 제거하고 반환합니다.
- **사용 예시:**
  - 프린터의 인쇄 작업 대기열
  - 너비 우선 탐색(BFS) 알고리즘
  - 메시지 큐 시스템

```python
from collections import deque # 큐를 위해서는 deque를 사용하는 것이 효율적

queue = deque()
queue.append(1) # Enqueue 1
queue.append(2) # Enqueue 2
queue.append(3) # Enqueue 3

print(queue) # deque([1, 2, 3])

item = queue.popleft() # Dequeue
print(item) # 1
print(queue) # deque([2, 3])
```
